const express = require("express");
const router = express.Router();
const sharp = require("sharp");
const axios = require("axios");
const path = require("path");
const fs = require("fs").promises;
const { v4: uuidv4 } = require("uuid");
const supabase = require("../supabaseClient");

// ‚ö° HTTP Performance Optimization
const httpAgent = new (require("http").Agent)({
  keepAlive: true,
  maxSockets: 50, // Maximum concurrent connections
  timeout: 10000, // 10 second timeout
});

const httpsAgent = new (require("https").Agent)({
  keepAlive: true,
  maxSockets: 50,
  timeout: 10000,
});

// ‚ö° Optimized axios instance for image downloads
const imageAxios = axios.create({
  timeout: 15000, // 15 second timeout
  maxRedirects: 3,
  httpAgent: httpAgent,
  httpsAgent: httpsAgent,
  headers: {
    "User-Agent": "WearUp-ImageProcessor/1.0",
  },
});

// Outfit kompozisyonu olu≈üturan endpoint
router.post("/compose", async (req, res) => {
  try {
    const {
      outfitId,
      items,
      backgroundSettings,
      canvasWidth = 512,
      canvasHeight = 512,
      resolutionScale = 3,
      clientCanvasWidth = 256,
      clientCanvasHeight = 256,
    } = req.body;

    console.log(`üé® Outfit kompozisyonu olu≈üturuluyor: ${outfitId}`);
    console.log(
      `üì± Client canvas g√∂r√ºn√ºm√º: ${clientCanvasWidth.toFixed(
        1
      )}x${clientCanvasHeight.toFixed(1)}`
    );
    console.log(
      `üìê Server canvas boyutu: ${canvasWidth}x${canvasHeight} (${resolutionScale}x y√ºksek √ß√∂z√ºn√ºrl√ºk)`
    );

    // Aspect ratio kontrol√º
    const clientAspectRatio = (clientCanvasWidth / clientCanvasHeight).toFixed(
      3
    );
    const serverAspectRatio = (canvasWidth / canvasHeight).toFixed(3);
    console.log(
      `üìè Aspect ratio kontrol√º: Client=${clientAspectRatio}, Server=${serverAspectRatio} ${
        clientAspectRatio === serverAspectRatio ? "‚úÖ" : "‚ùå"
      }`
    );

    console.log(`üñºÔ∏è  ${items.length} item i≈ülenecek`);

    // Canvas'ƒ± olu≈ütur - Client'tan gelen arkaplan ayarlarƒ±na g√∂re
    console.log("üé® Arkaplan ayarlarƒ±:", backgroundSettings);

    let canvas;
    let canvasBackgroundColor = { r: 255, g: 255, b: 255, alpha: 1 }; // Varsayƒ±lan beyaz

    if (
      backgroundSettings?.backgroundColor &&
      backgroundSettings.backgroundColor !== "#FFFFFF"
    ) {
      console.log(
        `üé® Client arkaplan rengi uygulanƒ±yor: ${backgroundSettings.backgroundColor}`
      );
      // Hex rengi RGB'ye √ßevir
      const hex = backgroundSettings.backgroundColor.replace("#", "");
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      canvasBackgroundColor = { r, g, b, alpha: 1 };
      console.log(`‚úÖ Canvas arkaplanƒ± RGB(${r}, ${g}, ${b}) olarak ayarlandƒ±`);
    } else {
      console.log("üé® Varsayƒ±lan beyaz arkaplan kullanƒ±lƒ±yor");
    }

    canvas = sharp({
      create: {
        width: canvasWidth,
        height: canvasHeight,
        channels: 4,
        background: canvasBackgroundColor,
      },
    });

    // Arkaplan ayarlarƒ± uygula
    if (backgroundSettings) {
      // Arkaplan resmi varsa
      if (backgroundSettings.backgroundImageUrl) {
        console.log(
          `üñºÔ∏è  Arkaplan resmi uygulanƒ±yor: ${
            backgroundSettings.backgroundImageUrl
          } (Opacity: ${backgroundSettings.backgroundOpacity || 0.2})`
        );
        try {
          const bgResponse = await imageAxios.get(
            backgroundSettings.backgroundImageUrl,
            {
              responseType: "arraybuffer",
            }
          );

          const bgBuffer = Buffer.from(bgResponse.data);
          const opacity = backgroundSettings.backgroundOpacity || 0.2;

          // Arkaplan resmini canvas boyutuna g√∂re yeniden boyutlandƒ±r
          const resizedBg = await sharp(bgBuffer)
            .resize(canvasWidth, canvasHeight, { fit: "cover" })
            .composite([
              {
                input: Buffer.from([
                  255,
                  255,
                  255,
                  Math.round(255 * (1 - opacity)),
                ]),
                raw: { width: 1, height: 1, channels: 4 },
                tile: true,
                blend: "over",
              },
            ])
            .png()
            .toBuffer();

          canvas = sharp(resizedBg);
        } catch (bgError) {
          console.error("Arkaplan resmi i≈ülenirken hata:", bgError);
        }
      }
    }

    // Item'larƒ± z-index'e g√∂re sƒ±rala
    const sortedItems = items.sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0));
    console.log(
      `üî¢ Item'lar z-index'e g√∂re sƒ±ralandƒ±. Sƒ±ralama:`,
      sortedItems.map((item) => `${item.id}(z:${item.zIndex || 0})`)
    );

    // ‚ö° PERFORMANCE OPTIMIZATION: Parallel item processing
    console.log("üöÄ Paralel item i≈üleme ba≈ülatƒ±lƒ±yor...");
    const startTime = Date.now();

    // Canvas scale fakt√∂r√ºn√º frontend'ten al
    const scaleFactor = resolutionScale;
    console.log(`üìè Canvas scale fakt√∂r√º: ${scaleFactor}x`);

    // ‚ö° 1. Paralel resim indirme ve i≈üleme
    const itemProcessingPromises = sortedItems.map(async (item, index) => {
      try {
        if (!item.imageUrl) {
          console.log(`‚ö†Ô∏è Item atlandƒ± (image URL yok): ${item.id}`);
          return null;
        }

        const processStartTime = Date.now();

        // Pozisyon ve boyut hesaplamalarƒ± (optimize edilmi≈ü)
        const baseItemWidth = 110 * scaleFactor;
        const baseItemHeight = 120 * scaleFactor;
        const finalItemWidth = baseItemWidth * (item.scale || 1);
        const finalItemHeight = baseItemHeight * (item.scale || 1);

        const centerOffsetX = (finalItemWidth - baseItemWidth) / 2;
        const centerOffsetY = (finalItemHeight - baseItemHeight) / 2;

        const baseScaledX = item.x * scaleFactor;
        const baseScaledY = item.y * scaleFactor;
        const scaledX = baseScaledX - centerOffsetX;
        const scaledY = baseScaledY - centerOffsetY;

        // ‚ö° 2. Optimized HTTP request with connection pooling
        const itemResponse = await imageAxios.get(item.imageUrl, {
          responseType: "arraybuffer",
        });

        const itemBuffer = Buffer.from(itemResponse.data);

        // ‚ö° 3. Optimized Sharp pipeline - tek seferde t√ºm transformations
        let sharpPipeline = sharp(itemBuffer).resize(
          Math.round(finalItemWidth),
          Math.round(finalItemHeight),
          {
            fit: "contain",
            background: { r: 0, g: 0, b: 0, alpha: 0 },
            withoutEnlargement: false, // B√ºy√ºtmeye izin ver
          }
        );

        // ‚ö° 4. Basitle≈ütirilmi≈ü border radius (sadece gerekirse)
        const shouldAddBorderRadius = scaleFactor >= 2; // Sadece y√ºksek √ß√∂z√ºn√ºrl√ºkte
        if (shouldAddBorderRadius) {
          const borderRadius = Math.min(
            20,
            Math.round(15 * scaleFactor * (item.scale || 1))
          );

          // ‚ö° Optimized SVG - daha basit
          const roundedCornerSvg = `<svg><rect width="${Math.round(
            finalItemWidth
          )}" height="${Math.round(
            finalItemHeight
          )}" rx="${borderRadius}" fill="white"/></svg>`;

          sharpPipeline = sharpPipeline.composite([
            {
              input: Buffer.from(roundedCornerSvg),
              blend: "dest-in",
            },
          ]);
        }

        // ‚ö° 5. Rotation optimizasyonu
        if (item.rotation && Math.abs(item.rotation) > 1) {
          // Sadece anlamlƒ± rotasyonlar
          sharpPipeline = sharpPipeline.rotate(item.rotation, {
            background: { r: 0, g: 0, b: 0, alpha: 0 },
          });
        }

        // ‚ö° 6. Tek seferde buffer'a √ßevir
        const processedBuffer = await sharpPipeline
          .png({
            quality: 90, // Slightly lower quality for speed
            compressionLevel: 6, // Faster compression
          })
          .toBuffer();

        const processTime = Date.now() - processStartTime;
        console.log(
          `‚ö° Item ${index + 1}/${sortedItems.length} i≈ülendi: ${
            item.id
          } (${processTime}ms)`
        );

        return {
          input: processedBuffer,
          left: Math.round(scaledX),
          top: Math.round(scaledY),
          itemId: item.id,
        };
      } catch (itemError) {
        console.error(`‚ùå Item i≈üleme hatasƒ± (${item.id}):`, itemError.message);
        return null; // Hatalƒ± item'larƒ± atla
      }
    });

    // ‚ö° 7. Paralel olarak t√ºm item'larƒ± i≈üle
    console.log(`üîÑ ${sortedItems.length} item paralel olarak i≈üleniyor...`);
    const processedItems = await Promise.all(itemProcessingPromises);

    // Null olanlarƒ± filtrele (hatalƒ± item'lar)
    const compositeArray = processedItems.filter(Boolean);

    const totalProcessTime = Date.now() - startTime;
    console.log(
      `‚úÖ ${compositeArray.length}/${sortedItems.length} item ba≈üarƒ±yla i≈ülendi (${totalProcessTime}ms total)`
    );
    console.log(
      `üìä Ortalama item ba≈üƒ±na: ${(
        totalProcessTime / compositeArray.length
      ).toFixed(1)}ms`
    );

    // ‚ö° 8. Optimized final composition
    const compositionStartTime = Date.now();
    console.log(
      `üéØ ${compositeArray.length} item canvas'a composite ediliyor...`
    );

    const finalImage = await canvas
      .composite(compositeArray)
      .png({
        quality: 95, // High quality for final output
        compressionLevel: 6, // Balanced compression
        progressive: true, // Progressive loading
      })
      .toBuffer();

    const compositionTime = Date.now() - compositionStartTime;
    const totalTime = Date.now() - startTime;
    const fileSizeMB = (finalImage.length / 1024 / 1024).toFixed(2);

    console.log(`‚úÖ Kompozisyon tamamlandƒ±! (${compositionTime}ms)`);
    console.log(`üìÅ Dosya boyutu: ${fileSizeMB} MB`);
    console.log(`‚è±Ô∏è Toplam s√ºre: ${totalTime}ms`);
    console.log(
      `üöÄ Performance: ${((1000 / totalTime) * compositeArray.length).toFixed(
        1
      )} items/second`
    );

    // √ñnceki cover'ƒ± sil (eƒüer varsa)
    try {
      if (outfitId) {
        console.log(`üóëÔ∏è √ñnceki cover kontrol ediliyor: ${outfitId}`);

        // Mevcut outfit'in cover URL'ini al
        const { data: outfitData, error: outfitError } = await supabase
          .from("outfits")
          .select("outfit_cover_url")
          .eq("id", outfitId)
          .single();

        if (!outfitError && outfitData?.outfit_cover_url) {
          // URL'den dosya adƒ±nƒ± √ßƒ±kar
          const oldCoverUrl = outfitData.outfit_cover_url;
          const urlParts = oldCoverUrl.split("/");
          const oldFileName = urlParts[urlParts.length - 1];

          // Eƒüer eski dosya covers bucket'ƒ±nda ise sil
          if (oldFileName && oldFileName.includes("outfit_composed_")) {
            console.log(`üóëÔ∏è Eski cover siliniyor: ${oldFileName}`);

            const { error: deleteError } = await supabase.storage
              .from("covers")
              .remove([oldFileName]);

            if (deleteError) {
              console.warn(`‚ö†Ô∏è Eski cover silinemedi: ${deleteError.message}`);
            } else {
              console.log(`‚úÖ Eski cover ba≈üarƒ±yla silindi: ${oldFileName}`);
            }
          }
        }
      }
    } catch (deleteError) {
      console.warn("‚ö†Ô∏è Eski cover silme i≈üleminde hata:", deleteError);
    }

    // Supabase'e yeni cover'ƒ± y√ºkle
    const fileName = `outfit_composed_${outfitId}_${Date.now()}.png`;
    console.log(`üì§ Yeni cover Supabase'e y√ºkleniyor: ${fileName}`);

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from("covers")
      .upload(fileName, finalImage, {
        contentType: "image/png",
        cacheControl: "3600",
      });

    if (uploadError) {
      console.error("‚ùå Supabase upload hatasƒ±:", uploadError);
      return res.status(500).json({
        success: false,
        message: "Resim y√ºklenirken hata olu≈ütu",
      });
    }

    console.log("‚úÖ Supabase upload ba≈üarƒ±lƒ±!");
    console.log("üìÅ Upload data:", uploadData);

    // Public URL'i al
    const {
      data: { publicUrl },
    } = supabase.storage.from("covers").getPublicUrl(fileName);

    console.log("üîó Olu≈üturulan Public URL:", publicUrl);
    console.log("üéØ Bucket: covers");
    console.log("üìù Dosya adƒ±:", fileName);
    console.log(`üéâ Outfit kompozisyonu ba≈üarƒ±yla olu≈üturuldu!`);

    res.json({
      success: true,
      data: {
        imageUrl: publicUrl,
        fileName: fileName,
      },
    });
  } catch (error) {
    console.error("Outfit kompozisyonu olu≈üturulurken hata:", error);
    res.status(500).json({
      success: false,
      message: "Outfit kompozisyonu olu≈üturulamadƒ±",
    });
  }
});

module.exports = router;
