const express = require("express");
const router = express.Router();
const multer = require("multer");
const fs = require("fs");
const path = require("path");
const { promisify } = require("util");
const writeFileAsync = promisify(fs.writeFile);
const unlinkAsync = promisify(fs.unlink);
const mkdirAsync = promisify(fs.mkdir);
const axios = require("axios");
const { createClient } = require("@supabase/supabase-js");

// Supabase client setup
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

const { GoogleGenerativeAI } = require("@google/generative-ai");
const { GoogleAIFileManager } = require("@google/generative-ai/server");

// Configure multer storage for temporary file storage
const storage = multer.diskStorage({
  destination: async function (req, file, cb) {
    const tempDir = path.join(__dirname, "../../temp/uploads");

    // Create directory if it doesn't exist
    try {
      await mkdirAsync(tempDir, { recursive: true });
    } catch (err) {
      if (err.code !== "EEXIST") {
        console.error("Error creating temp directory:", err);
      }
    }

    cb(null, tempDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const upload = multer({ storage: storage });

// Create results directory for saving processed images
const resultsDir = path.join(__dirname, "../../results");
// Ensure the results directory exists
(async () => {
  try {
    await mkdirAsync(resultsDir, { recursive: true });
    console.log("Results directory ready:", resultsDir);
  } catch (err) {
    if (err.code !== "EEXIST") {
      console.error("Error creating results directory:", err);
    }
  }
})();

// Gemini API setup
const apiKey = process.env.GEMINI_API_KEY;
const genAI = new GoogleGenerativeAI(apiKey);
const fileManager = new GoogleAIFileManager(apiKey);

/**
 * Generate an enhanced product photo prompt using Gemini 1.5 1.5
 * @param {string} productDetails - Optional product details to include in the prompt
 * @returns {Promise<string>} Enhanced prompt for product image retouching
 */
async function generateEnhancedPrompt(
  productDetails = "",
  generationConfig = {}
) {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash" });

    // Create the prompt request with two parts: product details and photo enhancement instructions
    const promptRequest = {
      contents: [
        {
          parts: [
            {
              text: `Product description: ${
                productDetails ||
                "A luxury jewellery item, most likely a gold or silver ring or necklace."
              }

Write a clear and concise retouching guideline that will convert this item into a high-resolution, professional product photograph. Use the details from the product description and be sure to include: a pure white background, soft natural shadows, and emphasis on the jewellery's sparkle and texture. Address the image-editing team directly, explaining how to present the product in the most polished, commercial manner. Keep the instruction in a single paragraph under 150 words.`,
            },
          ],
        },
      ],
    };

    // Log the prompt that will be sent to Gemini 1.5 Flash
    console.log("\n==== GEMINI 1.5 FLASH'A GÖNDERİLEN PROMPT - BAŞLANGIÇ ====");
    console.log(promptRequest.contents[0].parts[0].text);
    console.log("==== GEMINI 1.5 FLASH'A GÖNDERİLEN PROMPT - BİTİŞ ====\n");

    // Generate the enhanced prompt
    const result = await model.generateContent(promptRequest, generationConfig);
    const enhancedPrompt = result.response.text();

    // Log the enhanced prompt generated by Gemini 1.5 Flash
    console.log("\n==== GEMINI 1.5 FLASH'IN ÜRETTİĞİ PROMPT - BAŞLANGIÇ ====");
    console.log(enhancedPrompt);
    console.log("==== GEMINI 1.5 FLASH'IN ÜRETTİĞİ PROMPT - BİTİŞ ====\n");

    return enhancedPrompt;
  } catch (error) {
    console.error("Error generating enhanced prompt:", error);
    // Fallback to a default prompt in case of error
    return `Create a high-resolution professional product photo optimized for e-commerce display. Use a perfectly white background with a soft, natural shadow beneath the product. Ensure the image is sharp and detailed, with all metals appearing crisp, reflective, and polished. Remove all distractions and imperfections. Highlight the product's key features with accurate color representation and enhanced texture details.`;
  }
}

/**
 * Uploads the given file to Gemini.
 *
 * See https://ai.google.dev/gemini-api/docs/prompting_with_media
 */
async function uploadToGemini(path, mimeType, displayName = null) {
  console.log(`Uploading file ${path} to Gemini...`);
  const uploadResult = await fileManager.uploadFile(path, {
    mimeType,
    displayName: displayName || path,
  });
  const file = uploadResult.file;
  console.log(`Uploaded file ${file.displayName} as: ${file.name}`);
  return file;
}

/**
 * Uploads an image file to Supabase storage products bucket
 * @param {string} filePath - Path to the image file
 * @param {string} fileName - Name to use for the file in storage
 * @returns {Promise<string>} URL of the uploaded file
 */
async function uploadToSupabase(filePath, fileName) {
  try {
    console.log(
      `Uploading ${filePath} to Supabase products bucket as ${fileName}...`
    );

    // Read the file content
    const fileBuffer = await fs.promises.readFile(filePath);

    // Upload to Supabase
    const { data, error } = await supabase.storage
      .from("products")
      .upload(fileName, fileBuffer, {
        contentType: "image/png", // Adjust based on the actual file type if needed
        upsert: true, // Overwrite if exists
      });

    if (error) {
      console.error("Supabase upload error:", error);

      // Add more detailed error information based on the error type
      if (
        error.message &&
        error.message.includes("row-level security policy")
      ) {
        console.error(
          "Bu hata, Supabase'de 'products' bucket için Row Level Security (RLS) politikası kısıtlamasından kaynaklanıyor."
        );
        console.error(
          "Lütfen Supabase yönetici paneline giderek Storage -> products bucket -> Policies sekmesine gidin"
        );
        console.error("Ve aşağıdaki gibi bir INSERT politikası ekleyin:");
        console.error(`
        ---------- Policy Example -----------
        Name: Allow file uploads
        Definition: true 
        -------------------------------------
        `);
      }

      throw error;
    }

    // Get the public URL
    const { data: urlData } = supabase.storage
      .from("products")
      .getPublicUrl(fileName);

    console.log(`Successfully uploaded to Supabase: ${urlData.publicUrl}`);
    return urlData.publicUrl;
  } catch (err) {
    console.error("Failed to upload to Supabase:", err);
    throw err;
  }
}

// Route for processing images with Gemini
router.post(
  "/gemini-process",
  upload.fields([
    { name: "mainImage", maxCount: 1 },
    { name: "productImage", maxCount: 1 },
  ]),
  async (req, res) => {
    console.log("API endpoint çağrıldı");

    if (!req.files || !req.files.mainImage || !req.files.productImage) {
      console.log("Dosya bulunamadı", req.files);
      return res
        .status(400)
        .json({ error: "Both mainImage and productImage files are required" });
    }

    console.log(
      "Dosyalar alındı:",
      "mainImage:",
      req.files.mainImage[0].originalname,
      req.files.mainImage[0].mimetype,
      req.files.mainImage[0].size,
      "bytes",
      "productImage:",
      req.files.productImage[0].originalname,
      req.files.productImage[0].mimetype,
      req.files.productImage[0].size,
      "bytes"
    );

    console.log("req.body:", req.body);

    const mainImagePath = req.files.mainImage[0].path;
    const productImagePath = req.files.productImage[0].path;
    const mainImageMimeType = req.files.mainImage[0].mimetype;
    const productImageMimeType = req.files.productImage[0].mimetype;

    try {
      // Check if API key is available
      if (!apiKey) {
        console.log("API anahtarı bulunamadı");
        throw new Error(
          "GEMINI_API_KEY is not configured in environment variables"
        );
      }

      // Check if Supabase credentials are available
      if (!supabaseUrl || !supabaseKey) {
        console.log("Supabase credentials bulunamadı");
        throw new Error(
          "SUPABASE_URL or SUPABASE_KEY is not configured in environment variables"
        );
      }

      console.log("Gemini ile görüntü işleme başlatılıyor");

      // Process image with Gemini
      async function processImage() {
        try {
          // Upload both files to Gemini
          const uploadedMainImage = await uploadToGemini(
            mainImagePath,
            mainImageMimeType,
            req.files.mainImage[0].originalname
          );
          console.log("Ana görsel yüklendi:", uploadedMainImage.name);

          const uploadedProductImage = await uploadToGemini(
            productImagePath,
            productImageMimeType,
            req.files.productImage[0].originalname
          );
          console.log("Ürün görseli yüklendi:", uploadedProductImage.name);

          // Use Gemini 2.0 Flash for processing both images
          const model = genAI.getGenerativeModel({
            model: "gemini-2.5-flash-exp",
            generationConfig: {
              responseModalities: ["Text", "Image"],
              temperature: 1,
              topP: 0.95,
              topK: 40,
            },
          });

          console.log("Gemini 2.0 Flash ile görsel işleme başlatılıyor...");

          // Prepare the content with both uploaded images
          const content = [
            {
              fileData: {
                mimeType: uploadedMainImage.mimeType,
                fileUri: uploadedMainImage.uri,
              },
            },
            {
              fileData: {
                mimeType: uploadedProductImage.mimeType,
                fileUri: uploadedProductImage.uri,
              },
            },
            {
              text: 'Create a realistic visualization of the person in the first image wearing the item from the second image. Maintain the person\'s pose, facial expression, and overall composition. Make the final result look natural and professional, like a high-quality fashion photo shoot. The item from the second image should be perfectly integrated, with appropriate shadows, textures, and fit as if the person was actually wearing it.\n\nAlso, analyze the second image and identify what type of clothing or accessory item it is. Return this information in JSON format as follows:\n\n[{ "type": "THE ACTUAL CATEGORY NAME", "query": "DETAILED DESCRIPTION" }]\n\nNotes:\n1. For \'type\', use the specific product category name (NOT limited to fixed categories like Tops, Bottoms, etc). Use the most accurate category name for what you see (e.g., "Shirt", "Jeans", "Sneakers").\n2. For \'query\', provide a detailed description in English with color, pattern, style and other notable features.\n3. Example: if you see a blue shirt, it might be: [{ "type": "Shirt", "query": "blue striped button-up shirt" }]',
            },
          ];

          // Generate the content
          const response = await model.generateContent(content);
          console.log("\n==== GEMİNİ API YANIT BAŞLANGIÇ ====");
          console.log("Response received from Gemini API");
          console.log("==== GEMİNİ API YANIT BİTİŞ ====\n");

          // Log response structure for debugging
          console.log("Response structure:", Object.keys(response));

          let responseText = "";
          let generatedImages = [];
          let savedImagePaths = [];
          let supabaseUrls = [];

          // Process the response parts
          if (
            response.response &&
            response.response.candidates &&
            response.response.candidates.length > 0 &&
            response.response.candidates[0].content &&
            response.response.candidates[0].content.parts
          ) {
            console.log("Processing response parts...");

            for (const part of response.response.candidates[0].content.parts) {
              // Based on the part type, either extract text or image
              if (part.text) {
                console.log("Text part found:", part.text);
                responseText = part.text;
              } else if (part.inlineData) {
                console.log(`Image part found: ${part.inlineData.mimeType}`);

                // Save the image to both debug and results folders
                try {
                  // For debug purpose
                  const debugDir = path.join(__dirname, "../../temp/debug");
                  await mkdirAsync(debugDir, { recursive: true }).catch(
                    () => {}
                  );

                  // Generate file names
                  const imageExt =
                    part.inlineData.mimeType.split("/")[1] || "png";
                  const timestamp = Date.now();
                  const originalName =
                    req.files.mainImage[0].originalname.replace(
                      /\.[^/.]+$/,
                      ""
                    ); // Remove extension
                  const imageFileName = `${originalName}_processed_${timestamp}.${imageExt}`;

                  // Save to debug folder
                  const debugFilePath = path.join(debugDir, imageFileName);

                  // Save to results folder
                  const resultsFilePath = path.join(resultsDir, imageFileName);

                  const imageData = part.inlineData.data;
                  // Remove data URI prefix if present
                  const base64Data = imageData.replace(
                    /^data:image\/\w+;base64,/,
                    ""
                  );

                  // Write to both locations
                  await writeFileAsync(debugFilePath, base64Data, {
                    encoding: "base64",
                  });

                  await writeFileAsync(resultsFilePath, base64Data, {
                    encoding: "base64",
                  });

                  console.log(`Debug image saved to: ${debugFilePath}`);
                  console.log(`Result image saved to: ${resultsFilePath}`);

                  savedImagePaths.push(resultsFilePath);

                  // Upload to Supabase
                  try {
                    const supabaseUrl = await uploadToSupabase(
                      resultsFilePath,
                      `processed/${imageFileName}`
                    );
                    supabaseUrls.push(supabaseUrl);
                    console.log(`Image uploaded to Supabase: ${supabaseUrl}`);
                  } catch (supabaseError) {
                    console.error("Supabase upload error:", supabaseError);
                    // Continue processing even if upload fails
                  }

                  generatedImages.push({
                    mimeType: part.inlineData.mimeType,
                    savedPath: resultsFilePath,
                    supabaseUrl: supabaseUrls[supabaseUrls.length - 1] || null,
                  });
                } catch (e) {
                  console.error("Failed to save image:", e);
                }
              }
            }
          } else {
            console.log("Unexpected response structure:", response);
          }

          if (generatedImages.length === 0) {
            console.log("No images found in the response");
          } else {
            console.log(`Found ${generatedImages.length} images in response`);
            console.log(
              `Saved ${savedImagePaths.length} images to results folder`
            );
            console.log(
              `Uploaded ${supabaseUrls.length} images to Supabase products bucket`
            );
          }

          return {
            responseText: responseText,
            generatedImages: generatedImages,
            savedImagePaths: savedImagePaths,
            supabaseUrls: supabaseUrls,
          };
        } catch (error) {
          console.error("Image processing error:", error);
          throw error;
        }
      }

      // Run the image processing
      const processingResult = await processImage();

      // Clean up the temporary upload file
      await unlinkAsync(mainImagePath);
      await unlinkAsync(productImagePath);

      // Return successful response to client
      console.log("Başarılı yanıt dönülüyor");
      return res.status(200).json({
        success: true,
        message: "Image processed successfully",
        result: processingResult.responseText,
        imageUrl:
          processingResult.supabaseUrls.length > 0
            ? processingResult.supabaseUrls[0]
            : null,
        generatedImages: processingResult.generatedImages,
        savedImagePaths: processingResult.savedImagePaths,
        supabaseUrls: processingResult.supabaseUrls,
      });
    } catch (error) {
      console.error("Error processing image:", error);

      // Clean up temp files if they exist
      try {
        if (fs.existsSync(mainImagePath)) {
          await unlinkAsync(mainImagePath);
        }
        if (fs.existsSync(productImagePath)) {
          await unlinkAsync(productImagePath);
        }
      } catch (unlinkError) {
        console.error("Error deleting temp files:", unlinkError);
      }

      // Return error to client
      res.status(500).json({
        success: false,
        error: "Failed to process image",
        details: error.message,
      });
    }
  }
);

module.exports = router;
